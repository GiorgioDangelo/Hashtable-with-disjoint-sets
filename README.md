# Hashtable-with-disjoint-sets
Instrucion to compile:     g++ main.cpp LinkedList.cpp nodo_hashtable.cpp Hashtable.cpp -o esecuzione

1.1)Descrizione del problema  
Mi viene chiesto di creare un hashtable di cui ogni cella punta all’insieme disgiunto e implementare le funzione make-set(), find-set(), union(). 
Una tabella di hash è un struttura dati molto efficiente per implementare i dizionari. E’ molto importante perché l’inserimento di una chiave all’interno del vettore segui dei criteri ben precisi e da qui nasce la funzione hashing che si voglia usare.  Come funzione hash ho usato il metodo della divisione, consiste in questo:  Quando sto inserendo la chiave ad esempio 50 farò chiave modulo con il size del mio hashtable e mi ritornerà il resto della divisione e quello sarò l’indice dove inserirò la chiave.  Questo è molto importante per la ricerca perché ricercare un chiave significa calcolarne il modulo quindi so esattamente dove si trova e quindi mi prendere l’accesso all’elemento con complessità O(1).  Mi viene chiesto di implementare le varie funzioni:  MAKE-SET()=Creo una lista con un solo elemento  FIND-SET()=Dato un numero cerco il suo rappresentate  UNION()=Dati due chiavi unisco gli insiemi 
1.2)Descrizione strutture dati utilizzate  
Come strutture dati ho utilizzato per la costruzione dell’hashtable, una lista che mi rappresenta l’insieme disgiunto e un vettore dove inserirò i vari insiemi disgiunti nella posizione corretta del vettore dato dal criterio della funzione hash.  
1.3)Formato dati in input/output  Leggo un file input in cui ogni rigo è rappresentato da un intero e una stringa. 
1.4)Descrizione algoritmo  
L’algoritmo funziona in questo modo:  Leggo da un file in input le chiave e le stringhe, per ogni chiave userò la funzione hash (metodo della divisione) controllerò se la cella corrispondente al modulo della funzione hash è già occupata o meno indipendentemente se è occupata o meno mi creò un oggetto LinkedList che contiene la chiave la stringa e un puntantore. Se la cella non è occupata allora mi creerò l’oggetto hashtable che praticamente è come se fosse un nodo sentinella che punta alla testa e alla coda della lista e inserirò l’indirizzo dell’oggetto all’interno della cella. Se la cella è già occupata allora mi dichiaro una variabile temporanea in cui mi salvo il valore della testa della lista corrente dal nodo sentinella e scorrerò la lista fino a trovare il null e inserirò l’elemento (quindi è un inserimento in coda) e ogni volta aggiornerò la nuova coda, per ogni lista che creo avrò un vector che mi conterrà gli elementi presenti nella lista, questo mi servirà per la union.  Il primo elemento inserito nella cella sarà il rappresentantedell’insieme.  La union funziona in questo modo, praticamente avremo un menu dove potremmo inserire le due chiave che vogliamo inserire, effettuerò un controllo per vedere se le chiavi che sto cercando esistono e se le chiavi che sto cercando di inserirenon siano uguali, 
quindi con l’informazione che ho nel vector che tiene conto del size delle liste, unirò la lista con il size minore a quella con il size maggiore in modo da diminuire le operazioni di inserimento. Quindi semplicemente mi scorrerò la lista con size minore e la inserirò nella coda della lista con il size maggiore. Con la union nasce un problema una volta che ho inserito la lista 2 nella lista 1, se sto cercando ad esempio una chiave e quest’ultima si troverebbe nella lista 2 non la troverò perché ho inserito la lista 2 nella lista 1 e ciò comporterebbe un errore dunque farò puntatare la testa della lista 2 alla testa della lista 1.  La find-set() vuole che dato una chiave restituisco il suo rappresentante.  Quindi inserisco la chiave, con il metodo della divisione capirò in quale insieme disgiunto si trova, scorrerò la lista se trovo la chiave restituirò la testa della lista ossia dove si trova il rappresentante.  La make-set() vuole creare una lista con un solo elemento.  Quindi inserisco la chiave e la stringa, controllerò con la funzione hash della chiave se nell’indice restituito se il vettore con quell’indice è già occupato da un altro insieme, se quella cella è vuota creerò il nuovo insieme disgiunto ,se invece è occupata la make-set fallisce ma effettuerà un controllo e ci consiglierà la prima cella libera dove poter effettuare una make-set
1.5)Complessità  La complessità è data dalle operazioni che effettuiamo nell’hashtable.  Per popolare l’hashtable avremo un complessità data dalla funzione hash, nel caso migliore l’inserimento è O(1) se la cella è vuota, nel caso peggiore è O(n) in quanto la cella è già occupata e dobbiamo scorrere la lista e inserire il nuovo elemento in coda.  L’operazione find-set avrà come complessità O(1) nel momento in cui il find-set della chiave è la chiave stessa ,ossia la chiave che sto cercando è anche il rappresentante dell’insieme, mentre negli altri casi avrà complessità O(n) perché prima devo cercare se una determinata chiave esiste nell’insieme e dopo restituisco il rappresentante che è sempre l’operazione meno costosa in quando è la prima chiave della lista.  La make-set avrà complessità O(1) poiché vuole creare un insieme con un solo  Rappresentante quindi si tratterà di fare un inserimento con complessità O(1) tuttavia se              Avrò una complessità O(n) in quanto mi scorro l’hashtable fino a trovare una cella dove         posso effettuare la make-set Infine abbiamo la union, per migliorare la complessità abbiamo un vector in cui abbiamo i size delle varie liste, quando voglio unire due liste verifico quale sia la lista più piccola e quest’ultima verrà inserita nella coda della lista più grande, l’inserimento in questo caso è O(n).  Poichè inserirò N elementi e l’inserimento nel caso peggiore ha complessità O(n^2)
